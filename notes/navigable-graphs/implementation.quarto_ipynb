{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Navigable Graphs via Set Cover Implementation Notes\"\n",
        "format:\n",
        "    html:\n",
        "        theme: cosmo\n",
        "        toc: true\n",
        "        toc-depth: 2\n",
        "        number-sections: true\n",
        "        code-fold: true\n",
        "execute:\n",
        "    echo: true\n",
        "    warning: false\n",
        "    error: false\n",
        "# python: /usr/local/anaconda3/envs/aml/bin/python\n",
        "---\n",
        "\n",
        "\n",
        "::: {.hidden}\n",
        "\n",
        "\\newcommand*{\\e}{\\mathrm{e}}\n",
        "\\renewcommand{\\P}{\\mathrm{P}}\n",
        "\n",
        "$$\n",
        "\\DeclareMathOperator*{\\argmax}{argmax}\n",
        "$$\n",
        "\n",
        ":::\n",
        "\n",
        "So, I keep forgetting to write down exactly how I go about the implementation for building a navigable graph via set cover. So here goes. \n",
        "\n",
        "## Setup\n",
        "**Goal:** Construct a graph $G = (V, E)$ with the fewest number of edges such that $G$ is _navigable_ for some distance metric $d$. $G$ is navigable iff for every $s,t \\in V$, pair, there exists an out-edge $(s, k) \\in E$ s.t. $d(t, k) < d(s,k)$. \n",
        "\n",
        "Let $\\mathbf V$ be an $n \\times m$ matrix, which contains $n$ vectors of length $m$ and let $\\mathbf M \\in \\mathbb R^{n \\times n}$ be the distance matrix, such that the $i,j$th entry of $\\mathbf M$ corresponds to the distance between the $i$th and $j$th vectors in $\\mathbf V$. From $M$, we can compute a _permutation matrix_, $\\mathbf \\Pi^{-1} \\in \\mathbb N^{n \\times n}$, where $\\Pi^{-1}_{ij}$ is the positional rank of the $V_j$ in the sorted list of $V_i$'s nearest neighbors. I.e, if $\\Pi^{-1}_{ij} = k$, $V_j$ is $V_i$'s $k$th closest neighbor.\n",
        "\n",
        "## Vectorized Set Construction and Greedy Set Cover\n",
        "Consider solving the set cover instance on vector $V_i$. There are exactly $n-1$ sets, one for each of the other vectors and we will call these $S_{i \\to j}$. Each of the sets contains all the vectors that traversing the edge $(i,j)$ would bring a search algorithm strictly closer to. Formally:\n",
        "$$\n",
        "    S_{i\\to j} = \\left\\{k \\in [1, \\dots, n] : d(V_j, V_k) < d(V_i, V_k) \\right\\}\n",
        "$$\n",
        "Solving a set cover problem on these sets, i.e., picking the minimum number of sets whose union is $\\{1, \\dots, n\\}$, gives us a set of out edges from $V_i$ that would have at least one greedy edge for every other vector in the graph. We can build these sets using the inverse-permutation matrix as follows:\n",
        "\n",
        "- Let $\\mathbf S \\in \\{0,1\\}^{n \\times n}$ be the matrix whose $i,j$th columns corresponds to the set $S_{i \\to j}$, s.t., if $k \\in S_{i \\to j}$, then $S_{jk} = 1$, $0$ otherwise.\n",
        "- Select the $i$th column of $\\mathbf \\Pi^{-1}$, which gives tells us the rank of $V_i$ in every other vector's sorted nearest neighbor list. Call this $\\pi^{-1}_i$.\n",
        "- Compare $\\pi_i$ with every other column $\\pi_j$ entry-wise and set $S_{j k} = 1$ if $\\pi^{-1}_{j k} < \\pi^{-1}_{i k}$, $0$ otherwise.\n",
        "\n",
        "We can now run a greedy set cover algorithm on the columns of $\\mathbf S$. Let $\\mathbf u \\in \\{0, 1\\}^n$ be a vector to keep track of the uncovered elements. Initially, only the $i$th entry of $\\mathbf u$ is $0$ (since $V_i$ covers itself) and every $u_j = 1$ for $i \\neq j$. Each step of the greedy set cover will proceed as follows:\n",
        "\n",
        "- Select the column $S_j$ s.t. $$j = \\argmax_{j \\in [1, \\dots, n]} \\mathbf S^\\top \\mathbf u$$ This corresponds to selecting the set that covers the maximum number of uncovered elements.\n",
        "- Update the list of uncovered elements: $\\mathbf u \\gets \\overline{\\overline{\\mathbf u} \\mid \\mid S_j}$, where $\\overline{\\mathbf u}$ is the bitwise complement of $\\mathbf u$ and $\\mid\\mid$ is the bitwise or operation.\n",
        "- Repeat till $\\mathbf u$ is the all $0$s vector. \n",
        "\n",
        "## Example\n",
        "Consider the following set of points: $A(-2,2),B(2,1),C(1,-1),D(-3,-2),E(2,-3)$."
      ],
      "id": "1329ae6d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-align: center\n",
        "import numpy as np\n",
        "import networkx as nx\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "points = np.array([\n",
        "    [-2,2],\n",
        "    [2,1],\n",
        "    [1,-1],\n",
        "    [-3,-2],\n",
        "    [2,-3]\n",
        "])\n",
        "\n",
        "# Create a graph\n",
        "G = nx.Graph()\n",
        "\n",
        "# Add nodes with positions\n",
        "for i, (x, y) in enumerate(points):\n",
        "    G.add_node(chr(i+65), pos=(x, y))\n",
        "\n",
        "# Get positions dictionary\n",
        "pos = nx.get_node_attributes(G, 'pos')\n",
        "\n",
        "# Draw the graph\n",
        "plt.figure(figsize=(4, 4))\n",
        "nx.draw_networkx_nodes(G, pos, node_color='black', node_size=300)\n",
        "nx.draw_networkx_labels(G, pos, font_color='white')\n",
        "\n",
        "plt.axis('off')\n",
        "plt.show()"
      ],
      "id": "4d49df8c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The distance matrix (with Euclidean distances) is:"
      ],
      "id": "c8f3c2c3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: asis\n",
        "\n",
        "import numpy as np\n",
        "from scipy.spatial.distance import cdist\n",
        "\n",
        "points = np.array([\n",
        "    [-2,2],\n",
        "    [2,1],\n",
        "    [1,-1],\n",
        "    [-3,-2],\n",
        "    [2,-3]\n",
        "])\n",
        "\n",
        "# Compute squared distances\n",
        "grid = cdist(points, points, metric='sqeuclidean')\n",
        "grid = grid.astype(int)\n",
        "\n",
        "# Build LaTeX string with sqrt symbols\n",
        "latex_matrix = r'\\begin{equation*}\\mathbf{M} = \\begin{bmatrix}'\n",
        "rows = [' & '.join(r'\\sqrt{' + str(int(val)) + r'}' for val in row) for row in grid]\n",
        "latex_matrix += r' \\\\ '.join(rows)\n",
        "latex_matrix += r'\\end{bmatrix}\\end{equation*}'\n",
        "print(latex_matrix)"
      ],
      "id": "f9daf82a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "and the permutation matrix is:"
      ],
      "id": "17510bf6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: asis\n",
        "\n",
        "import numpy as np\n",
        "from scipy.spatial.distance import cdist\n",
        "from scipy.stats import rankdata\n",
        "\n",
        "points = np.array([\n",
        "    [-2,2],\n",
        "    [2,1],\n",
        "    [1,-1],\n",
        "    [-3,-2],\n",
        "    [2,-3]\n",
        "])\n",
        "\n",
        "# Compute squared distances\n",
        "grid = rankdata(cdist(points, points, metric='sqeuclidean'), method='ordinal', axis=-1)\n",
        "grid = grid.astype(int)\n",
        "\n",
        "# Build LaTeX string with sqrt symbols\n",
        "latex_matrix = r'\\begin{equation*}\\mathbf{\\Pi^{-1}} = \\begin{bmatrix}'\n",
        "rows = [' & '.join(str(int(val)) for val in row) for row in grid]\n",
        "latex_matrix += r' \\\\ '.join(rows)\n",
        "latex_matrix += r'\\end{bmatrix}\\end{equation*}'\n",
        "print(latex_matrix)"
      ],
      "id": "91a288db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "_(more code and explanation to come)..._"
      ],
      "id": "bf7a2a8a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}